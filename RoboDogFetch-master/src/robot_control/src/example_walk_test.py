#!/usr/bin/python

import sys
import time
import math
sys.path.append('../lib/python/amd64')
import robot_interface as sdk

# This is the part where you integrate with the path planner node
# Assuming you have some way to get the path waypoints

class RobotControl:
    def __init__(self):
        HIGHLEVEL = 0xee  # Control mode
        self.udp = sdk.UDP(HIGHLEVEL, 8080, "192.168.123.161", 8082)
        self.cmd = sdk.HighCmd()
        self.state = sdk.HighState()
        self.udp.InitCmdData(self.cmd)
        self.motion_time = 0

        # Initialize other parameters
        self.path = None  # Path from A* planner
        self.current_target_idx = 0  # Index of the current target waypoint

    def send_velocity_command(self, velocity_x, velocity_y, yaw_speed=0.0):
        """
        Function to send velocity commands to the robot.
        This will be used to control the robot's walk based on the path planner.
        """
        self.cmd.mode = 2  # Walking mode
        self.cmd.gaitType = 1  # Gait type: 1 for trot, 2 for flying trot, adjust as needed
        self.cmd.velocity = [velocity_x, velocity_y]  # X and Y velocities
        self.cmd.yawSpeed = yaw_speed  # Yaw control for turning
        self.cmd.footRaiseHeight = 0.1  # Adjust foot raise height for obstacles
        self.cmd.bodyHeight = 0  # Adjust body height if needed (optional)

        # Send the command to the robot
        self.udp.SetSend(self.cmd)
        self.udp.Send()
    #This function moves the robot based on the path generated by the planner.
    def follow_path(self):
        
        #The robot moves towards each waypoint sequentially.
        while self.path is not None and self.current_target_idx < len(self.path):
            current_target = self.path[self.current_target_idx]

            # Get current robot position from state (assumed to be (x, y))
            robot_x, robot_y = self.get_robot_position()

            # Get the target waypoint (converted to real-world coordinates)
            target_x = current_target[0] * 0.1  # Assuming grid is scaled by 0.1 meters
            target_y = current_target[1] * 0.1

            # Calculate the direction vector to the next waypoint
            direction_x = target_x - robot_x
            direction_y = target_y - robot_y
            distance_to_target = math.sqrt(direction_x**2 + direction_y**2)

            # If we're close to the target, move to the next waypoint
            if distance_to_target < 0.1:
                self.current_target_idx += 1
                continue

            # Normalize the velocity to avoid exceeding the maximum speed
            max_speed = 0.4  # Maximum speed (m/s)
            velocity_x = direction_x / distance_to_target * max_speed
            velocity_y = direction_y / distance_to_target * max_speed

            # Optionally calculate yaw speed for turning (based on target direction)
            yaw_speed = 0.0  # Set to 0 for now, can add yaw control logic if needed

            # Send the velocity command to the robot
            self.send_velocity_command(velocity_x, velocity_y, yaw_speed)

            # Short delay to simulate control loop timing
            time.sleep(0.1)

    def get_robot_position(self):
        """
        Retrieve the robot's current position from the robot state.
        This should be replaced with real sensor/odometry data.
        """
        self.udp.Recv()
        self.udp.GetRecv(self.state)

        # For now, just assume (0, 0) as the robot's position; replace with real data
        robot_x = 0.0
        robot_y = 0.0

        return robot_x, robot_y

    def set_path(self, new_path):
        """
        Set a new path for the robot to follow.
        This would typically be called when the A* path is updated.
        """
        self.path = new_path
        self.current_target_idx = 0  # Reset the waypoint index

if __name__ == '__main__':
    # Initialize robot control
    robot_control = RobotControl()

    # Assume the path planner will provide a path to follow
    # Example path (list of waypoints): each waypoint is (x, y) in grid coordinates
    #example_path = [(1, 2), (2, 3), (3, 4), (4, 5)]  # Replace this with real path from path planner
    #robot_control.set_path(example_path)

    # Main control loop
    while True:
        # Follow the path continuously
        robot_control.follow_path()

        # Break the loop or stop the robot if needed (e.g., path is completed)
        if robot_control.current_target_idx >= len(robot_control.path):
            # Stop the robot after reaching the final target
            robot_control.send_velocity_command(0, 0)
            break
 